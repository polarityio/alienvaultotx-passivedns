"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestWithDefaultsBuilder = void 0;
const fs = require("fs");
const postman_request_1 = __importDefault(require("postman-request"));
const fp_1 = require("lodash/fp");
const bottleneck_1 = __importDefault(require("bottleneck"));
const logging_1 = __importDefault(require("../logging"));
const errors_1 = __importDefault(require("../errors"));
const _configFieldIsValid = (field) => typeof field === 'string' && field.length > 0;
let limiter;
function _setupLimiter(options) {
    limiter = new bottleneck_1.default({
        maxConcurrent: options.maxConcurrentRequests
            ? Number.parseInt(options.maxConcurrentRequests, 10)
            : 10,
        highWater: 50,
        strategy: bottleneck_1.default.strategy.OVERFLOW,
        minTime: options.minimumMillisecondsRequestWillTake
            ? Number.parseInt(options.minimumMillisecondsRequestWillTake, 10)
            : 200
    });
}
/**
 * @param interface CreateRequestFunctionArguments {
 *   config?: type ConfigJs = {
 *     request: {
 *       ca?: string;
 *       cert?: string;
 *       key?: string;
 *       passphrase?: string;
 *       rejectUnauthorized?: string;
 *       proxy?: string;
 *       json?: boolean;
 *     };
 *   } | undefined;
 *     * The entire config.js(on) object
 *   roundedSuccessStatusCode?: number[];
 *     * Defaults: [200]
 *     * Status codes, rounded to the 100's place, that should not throw errors.
 *   useLimiter?: boolean;
 *     * Defaults: false
 *     * Set limit params in options (options.maxConcurrentRequests [default 10] & options.minimumMillisecondsRequestWillTake [default 200]) passed when
 *       using the RequestWithDefaultsFunction this function returns
 *       which can be hardcoded or can come from the userOptions directly
 *   requestOptionsToOmitFromLogsKeyPaths?: string[];
 *     * Defaults: ['headers.Authorization']
 *     * Key Paths on the Request Options you wish to not automatically log.
 *   preprocessRequestOptions?: type PreprocessRequestOptionsFunction =
 *     (requestOptions: RequestOptions) => Promise<object> | never | undefined;
 *   postprocessRequestResponse?: type PostprocessRequestResponseFunction =
 *     (response: any, requestOptions: RequestOptions) => Promise<any> | never | undefined;
 *   postprocessRequestFailure?: type PostprocessRequestFailureFunction =
 *     (error: Error, requestOptions: RequestOptions) => Promise<any> | never | undefined;
 * }
 * @returns type RequestWithDefaultsFunction = (requestOptions: RequestOptions) => Promise<any> | never
 *   * Returns an async request function with the proxy defaults included in the request options
 *   * type RequestOptions = {
 *       url?: string;
 *       headers?: object;
 *       qs?: object;
 *       options?: object;
 *       entity?: object;
 *       form?: object;
 *       [key: string]: any;
 *    }
};
 */
const createRequestWithDefaults = ({ config: { request: { ca, cert, key, passphrase, rejectUnauthorized, proxy, json } } = {
    request: {
        ca: '',
        cert: '',
        key: '',
        passphrase: '',
        proxy: '',
        rejectUnauthorized: false,
        json: true
    }
}, roundedSuccessStatusCodes = [200], useLimiter = false, requestOptionsToOmitFromLogsKeyPaths = ['headers.Authorization'], preprocessRequestOptions = (requestOptions) => __awaiter(void 0, void 0, void 0, function* () { return ({}); }), postprocessRequestResponse = (response, requestOptions) => __awaiter(void 0, void 0, void 0, function* () { return response; }), postprocessRequestFailure = (error, requestOptions) => __awaiter(void 0, void 0, void 0, function* () {
    throw error;
}) }) => {
    const defaultsProxyOptions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (_configFieldIsValid(ca) && { ca: fs.readFileSync(ca) })), (_configFieldIsValid(cert) && { cert: fs.readFileSync(cert) })), (_configFieldIsValid(key) && { key: fs.readFileSync(key) })), (_configFieldIsValid(passphrase) && { passphrase })), (_configFieldIsValid(proxy) && { proxy })), (typeof rejectUnauthorized === 'boolean' && { rejectUnauthorized })), { json });
    const requestDefaultsWithInterceptors = (0, exports.requestWithDefaultsBuilder)(defaultsProxyOptions, roundedSuccessStatusCodes, useLimiter, requestOptionsToOmitFromLogsKeyPaths, preprocessRequestOptions, postprocessRequestResponse, postprocessRequestFailure);
    return requestDefaultsWithInterceptors;
};
const requestWithDefaultsBuilder = (defaultsProxyOptions, roundedSuccessStatusCodes, useLimiter, requestOptionsToOmitFromLogsKeyPaths, preprocessRequestOptions, postprocessRequestResponse, postprocessRequestFailure) => {
    const defaultsRequest = postman_request_1.default.defaults(defaultsProxyOptions);
    const _requestWithDefaults = (requestOptions) => new Promise((resolve, reject) => {
        defaultsRequest(requestOptions, (err, res) => {
            if (err)
                return reject(err);
            resolve(res);
        });
    });
    return (requestOptions) => __awaiter(void 0, void 0, void 0, function* () {
        if (useLimiter && !limiter)
            _setupLimiter(requestOptions.options);
        const preRequestFunctionResults = yield preprocessRequestOptions(requestOptions);
        const _requestOptions = Object.assign(Object.assign({}, requestOptions), preRequestFunctionResults);
        let postRequestFunctionResults, result;
        try {
            result = yield (useLimiter
                ? limiter.schedule(_requestWithDefaults, _requestOptions)
                : _requestWithDefaults(_requestOptions));
            checkForStatusError(result, _requestOptions, roundedSuccessStatusCodes, requestOptionsToOmitFromLogsKeyPaths);
            postRequestFunctionResults = yield postprocessRequestResponse(result, _requestOptions);
        }
        catch (error) {
            try {
                postRequestFunctionResults = yield postprocessRequestFailure(error, _requestOptions);
            }
            catch (error) {
                const err = errors_1.default.parseErrorToReadableJson(error);
                if (useLimiter) {
                    error.maxRequestQueueLimitHit =
                        ((0, fp_1.isEmpty)(err) && (0, fp_1.isEmpty)(result)) ||
                            (err &&
                                (err.message ===
                                    'This job has been dropped by Bottleneck for going over API Limits' ||
                                    err instanceof bottleneck_1.default.BottleneckError));
                    error.isConnectionReset =
                        (0, fp_1.getOr)('', 'errors[0].meta.err.code', err) === 'ECONNRESET';
                }
                if (_requestOptions.entity)
                    error.entity = JSON.stringify(_requestOptions.entity);
                throw error;
            }
        }
        return postRequestFunctionResults;
    });
};
exports.requestWithDefaultsBuilder = requestWithDefaultsBuilder;
const checkForStatusError = ({ statusCode, body }, requestOptions, roundedSuccessStatusCodes, requestOptionsToOmitFromLogsKeyPaths) => {
    const Logger = logging_1.default.getLogger();
    const requestOptionsWithoutSensitiveData = (0, fp_1.omit)(requestOptionsToOmitFromLogsKeyPaths.concat('options'), requestOptions);
    Logger.trace({
        MESSAGE: 'Request Ran, Checking Status...',
        statusCode,
        requestOptions: requestOptionsWithoutSensitiveData,
        responseBody: body
    });
    const roundedStatus = Math.round(statusCode / 100) * 100;
    const statusCodeNotSuccessful = !roundedSuccessStatusCodes.includes(roundedStatus);
    const responseBodyError = (0, fp_1.get)('error', body);
    if (statusCodeNotSuccessful || responseBodyError) {
        const message = (0, fp_1.get)('message', responseBodyError);
        const status = statusCodeNotSuccessful ? statusCode : (0, fp_1.get)('code', responseBodyError);
        const description = JSON.stringify(body);
        const requestOptions = JSON.stringify(requestOptionsWithoutSensitiveData);
        const requestError = new errors_1.default.RequestError(message, status, description, requestOptions);
        throw requestError;
    }
};
exports.default = createRequestWithDefaults;
